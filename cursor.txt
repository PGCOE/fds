Cursors: (All types: Implicit, Explicit, Cursor FOR Loop, Parameterized Cursor)
Write a PL/SQL block of code using parameterized Cursor, that will merge the data available in the
newly created table N_RollCall with the data available in the table O_RollCall. If the data in the first
table already exist in the second table then that data should be skipped.
Frame the separate problem statement for writing PL/SQL block to implement all types
of Cursors inline with above statement. The problem statement should clearly state the
requirements.
Roll No:
Student Name:
Program and Output:
2.Write an anonymous code block to demonstrate use of explicit cursor,for loop &amp;
parametrized explicit cursor.Copy the content of student table to another table.Before
copying,check whether second table consists of same roll number record.If so,discard it
otherwise copy it.
create table student2(roll_no int,name varchar(20),marks int);
insert into student2 values(1,&#39;abc&#39;,39);
insert into student2 values(2,&#39;pqr&#39;,35);
insert into student2 values(3,&#39;xyz&#39;,41);
insert into student2 values(4,&#39;cde&#39;,37);
insert into student2 values(5,&#39;lmo&#39;,46);

create table newstudent2(roll_no int,name varchar(20),marks int);
insert into newstudent2 values(1,&#39;abc&#39;,45);
insert into newstudent2 values(3,&#39;xyz&#39;,45);
insert into newstudent2 values(7,&#39;xyzr&#39;,95);
insert into newstudent2 values(8,&#39;pqrs&#39;,65);
select * from student2;
select * from newstudent2;

declare
cursor cur_s is select * from student2; --cursor for student2 table
cursor cur_new(a int) is select * from newstudent2 where roll_no =a;
nrec newstudent2%rowtype;
begin
for srec in cur_s

loop
open cur_new(srec.roll_no);
--fetch cur_new into nrec;
if cur_new%notfound then
insert into newstudent2 values(srec.roll_no,srec.name,srec.marks);
end if;
close cur_new;
end loop;
end;
/
SELECT * FROM newstudent2;
%FOUND
Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows or a SELECT
INTO statement returned one or more rows. Otherwise, it returns FALSE.
%NOTFOUND
The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or DELETE statement
affected no rows, or a SELECT INTO statement returned no rows. Otherwise, it returns FALSE.

Problem Statement:
1.Write an anonymous code block which will update marks of students to 40 if he has
scored between 35 to 39.Using implicit cursor parameters show database whether any
records have been updated or not.If updated,display how many records have been
updated.

create table student2(roll_no int,name varchar(20),marks int);
insert into student2 values(1,&#39;abc&#39;,39);
insert into student2 values(2,&#39;pqr&#39;,35);
insert into student2 values(3,&#39;xyz&#39;,41);
insert into student2 values(4,&#39;cde&#39;,37);
insert into student2 values(5,&#39;lmo&#39;,46);
select * from student2;

begin
update student2 set marks=40 where marks between 35 and 39;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/

select * from student2;

set serveroutput on;
declare
begin
update student2 set marks=40 where marks between 35 and 39;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/

declare
begin
update student2 set marks=45 where marks between 35 and 44;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/
select * from student2;

----------------------------------------------------------------------------x-------------------------------------------------------------
dml
Cursors: (All types: Implicit, Explicit, Cursor FOR Loop, Parameterized Cursor)
Write a PL/SQL block of code using parameterized Cursor, that will merge the data available in the
newly created table N_RollCall with the data available in the table O_RollCall. If the data in the first
table already exist in the second table then that data should be skipped.
Frame the separate problem statement for writing PL/SQL block to implement all types
of Cursors inline with above statement. The problem statement should clearly state the
requirements.
Roll No:
Student Name:
Program and Output:
2.Write an anonymous code block to demonstrate use of explicit cursor,for loop &amp;
parametrized explicit cursor.Copy the content of student table to another table.Before
copying,check whether second table consists of same roll number record.If so,discard it
otherwise copy it.
create table student2(roll_no int,name varchar(20),marks int);
insert into student2 values(1,&#39;abc&#39;,39);
insert into student2 values(2,&#39;pqr&#39;,35);
insert into student2 values(3,&#39;xyz&#39;,41);
insert into student2 values(4,&#39;cde&#39;,37);
insert into student2 values(5,&#39;lmo&#39;,46);

create table newstudent2(roll_no int,name varchar(20),marks int);
insert into newstudent2 values(1,&#39;abc&#39;,45);
insert into newstudent2 values(3,&#39;xyz&#39;,45);
insert into newstudent2 values(7,&#39;xyzr&#39;,95);
insert into newstudent2 values(8,&#39;pqrs&#39;,65);
select * from student2;
select * from newstudent2;

declare
cursor cur_s is select * from student2; --cursor for student2 table
cursor cur_new(a int) is select * from newstudent2 where roll_no =a;
nrec newstudent2%rowtype;
begin
for srec in cur_s

loop
open cur_new(srec.roll_no);
--fetch cur_new into nrec;
if cur_new%notfound then
insert into newstudent2 values(srec.roll_no,srec.name,srec.marks);
end if;
close cur_new;
end loop;
end;
/
SELECT * FROM newstudent2;
%FOUND
Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows or a SELECT
INTO statement returned one or more rows. Otherwise, it returns FALSE.
%NOTFOUND
The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or DELETE statement
affected no rows, or a SELECT INTO statement returned no rows. Otherwise, it returns FALSE.

Problem Statement:
1.Write an anonymous code block which will update marks of students to 40 if he has
scored between 35 to 39.Using implicit cursor parameters show database whether any
records have been updated or not.If updated,display how many records have been
updated.

create table student2(roll_no int,name varchar(20),marks int);
insert into student2 values(1,&#39;abc&#39;,39);
insert into student2 values(2,&#39;pqr&#39;,35);
insert into student2 values(3,&#39;xyz&#39;,41);
insert into student2 values(4,&#39;cde&#39;,37);
insert into student2 values(5,&#39;lmo&#39;,46);
select * from student2;

begin
update student2 set marks=40 where marks between 35 and 39;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/

select * from student2;

set serveroutput on;
declare
begin
update student2 set marks=40 where marks between 35 and 39;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/

declare
begin
update student2 set marks=45 where marks between 35 and 44;
if SQL%notfound then
dbms_output.put_line(&#39;No records were updated&#39;);
else
dbms_output.put_line(&#39;Total records updated:&#39;||sql%rowcount);
end if;
end;
/
select * from student2;
-------------------------------------------------------------------------------x---------------------------------------------------
DDL
Roll No:

Student Name:

Program and Output:

In Mysql

Step 1 : create required tables

Use database name

create table Department(dept_no int,dept_name varchar(15),bldg_name varchar(15),unique(dept_name));

desc Department;

Add three records in table

Insert into Department (dept_no,dept_name,bldg_name) values (1,’COMP’,’B1’);

Insert into Department (dept_no,dept_name,bldg_name) values (2,’ENTC’,’B2’);

Insert into Department (dept_no,dept_name,bldg_name) values (3,’IT’,’B3’);

create table instructor(ins_id int,ins_name varchar(15) not null,dept_no int,salary int,mob_no int,primary key(ins_id));

desc instructor;

Add three records in table

Insert into instructor (ins_id ,ins_name ,dept_no ,salary ,mob_no) values (11,’Kiran’,1,20000,98);

Insert into instructor (ins_id ,ins_name ,dept_no ,salary ,mob_no) values (12,’Rohan’,2,20000,987654321);

Insert into instructor (ins_id ,ins_name ,dept_no ,salary ,mob_no) values (13,’Ram’,3,20000,987654222);

create table course(course_id int,title varchar(15),dept_no int,credits int,primary

key(course_id));

desc course;

Add three records in table

Insert into course (course_id ,title,dept_no ,credits ) values (111,’COMP’,1,10);

Insert into course (course_id ,title,dept_no ,credits ) values (222,’ENTC’,2,10);

Insert into course (course_id ,title,dept_no ,credits ) values (333,’IT’,3,10);

create table teachers(teacher_id int,course_id int,semester int,year year,foreign key

(teacher_id) references instructor(ins_id),foreign key (course_id) references

course(course_id));

desc teachers;

Quieries :

1)Add the primary key in department table.

alter table Department add primary key(dept_no);

desc Department;

2 Add the foreign key in instructor table.

alter table instructor add foreign key(dept_no) references Department(dept_no);

desc instructor;

3 Modify the table department by adding a column budget.

alter table Department add column budget int;

select * from Department;

4 Create unique index on mobile number of instructor table.

create unique index sr on instructor(mob_no);

desc instructor;

5 Create a view of instructor relation except the salary field.

create view inst_view as select ins_id,ins_name,dept_no,mob_no from instructor;

select * from inst_view;

6 Insert record into instructor table using newly created viewname.

insert into Department values(4,"Elect","D",null);

select * from Department;

select * from inst_view;

insert into inst_view values(4,"D",4,12000);

select * from inst_view;

7 Update the department number of particular instructor using update view.

update inst_view set dept_no=2 where ins_id=4;

select * from inst_view;

8 Delete record of particular instructor from instructor table using newly created

viewname.

delete from inst_view where ins_id=4;

9 Delete the last view.

drop view inst_view;

select * from inst_view;

10 Remove the Budget from department table.

alter table Department drop budget;

select * from Department;

11 Increase the size of the title field of course relation.

alter table course modify title varchar(20);

desc course;

12 Create a view by showing a instructor name with a department name and its

salary.

create view newview1 as select ins_name,dept_name,salary from instructor,Department

where instructor.dept_no=Department.dept_no;

select * from newview1;

13 Update salary of particular instructor using update view.

update newview1 set salary=11000 where ins_name="C";

select * from instructor;

14 Delete the index from the instructor table.

alter table instructor drop index sr;

desc instructor;

15 Rename the course table to another table name.

rename table course to coursetable;

desc coursetable;

16 Create a view by showing a instructor name and title of course he teaches.

create view newview2 as select ins_name,title from instructor,coursetable where

instructor.dept_no=coursetable.dept_no;

select * from newview2;

17 Delete the key from the department table.

alter table instructor drop foreign key instructor_ibfk_1;

alter table Department drop primary key;

desc instructor;

18 create the table student having field student id,student

name,dept_no,birth date. student id should be auto_increment.

Dept_no is foreign key.

alter table Department add primary key(dept_no);

create table Student(stud_id int auto_increment,stud_name varchar(10),dept_no

int,DOB date,foreign key(dept_no) references Department(dept_no),primary

key(stud_id));

desc Student;

19 Change the sequence of your auto increment field.

select * from Student;

alter table Student auto_increment=5;

select * from Student;

20 Create the view of computer department teachers name who teaches

in 5th semester.

create view new1 as select dept_name,semester,ins_name from

Department,teachers,instructor where teachers.semester=2 and

Department.dept_name="comp" and instructor.ins_id=teachers.teacher_id and

instructor.dept_no=Department.dept_no;

select * from new1;

Oracle SQL

Sequence:

Create table suppliers (supplier_id int, supplier_name varchar(20));

CREATE SEQUENCE supplier_seq

MINVALUE 1

START WITH 1

INCREMENT BY 1

CACHE 2;

INSERT INTO suppliers (supplier_id, supplier_name) VALUES (supplier_seq.NEXTVAL, 'Kraft Foods');

select * from suppliers;

Synonym:

CREATE PUBLIC SYNONYM supp FOR suppliers;

SELECT * FROM supp;

CREATE OR REPLACE PUBLIC SYNONYM supp FOR suppliers;

DROP PUBLIC SYNONYM supp;

Create table suppliers (supplier_id int, supplier_name varchar(20))
-------------------------------------------------------------------------------x-----------------------------------------------------
innerjoin
Drop table branchmaster;

Create table Branchmaster(branch_id int, branch_name varchar(15));

Insert into branchmaster values (1, ’Kharadi’);

Insert into branchmaster values (2, ’wagholi’);

Insert into branchmaster values (3, ’Hadapsar’);

Select * from branchmaster;

Drop table empmaster;

Create table Empmaster(emp_id int,emp_name varchar(15), branch_id int, salary int, dept varchar(15),manager_id varchar(10));

Insert into empmaster values(10, ’aryan’,2,40000, ’manager’,11);

Insert into empmaster values(11, ’kiran’,4,20000, ’admin’,12);

Insert into empmaster values(12, ’peter’,3,50000, ’HR’,13);

+--------+----------+-----------+--------+-----------+------------+

| emp_id | emp_name | branch_id | salary | dept | manager_id |

+--------+----------+-----------+--------+-----------+------------+

| 10 | Aryan | 2 | 40000 | Manager | NULL |

| 11 | Kiran | 4 | 5000 | Admin | 10 |

| 12 | Carol | 1 | 60000 | Assistant | 10 |

| 13 | Peter | 3 | 120000 | Senior | 10 |

| 14 | Bob | 5 | 110000 | HR | 10 |

+--------+----------+-----------+--------+-----------+------------+

Create table contactdetails(emp_id int,email_id varchar(20), phone_no int);

Insert into contactdetails values (10, ’peter@gmail.com’,1234567890);

Insert into contactdetails values (11, ’kiran@gmail.com’,1234567891);

Insert into contactdetails values (12, ’arayn@gmail.com’,1234567892);

+--------+-----------------+------------+

| emp_id | email_id | phone_no |

+--------+-----------------+------------+

| 11 | kiran@gmail.com | 9890154761 |

| 10 | aryan@gmail.com | 8806058754 |

| 13 | peter@hotmail.c | 9373203456 |

+--------+-----------------+------------+

Create table Branchaddress(branch_id int ,city varchar(15), state varchar(15));

Insert into Branchaddress values (1, ’pune’, ’Maharashtra’);

Insert into Branchaddress values (2, ’mumbai’, ’Maharashtra’);

Insert into Branchaddress values (3, ’kolkata’, ’bengal’);

+-----------+-----------+-------------+

| branch_id | city | state |

+-----------+-----------+-------------+

| 1 | Pune | Maharashtra |

| 2 | Kolkata | West Bengal |

| 3 | Mumbai | Maharashtra |

| 4 | Bangalore | Karnataka |

| 5 | Cuttack | Orissa |

+-----------+-----------+-------------+

Create table Empaddressdetails(emp_id int ,street varchar(20),city varchar(15),state varchar(15));

Insert into Empaddressdetails values (10, ’vadgoan’,’pune’, ’Maharashtra’);

Insert into Empaddressdetails values (11, ’link road’, ’mumbai’, ’Maharashtra’);

Insert into Empaddressdetails values (12, ’park road’,’kolkata’, ’bengal’);

+--------+------------+-----------+-------------+

| emp_id | street | city | state |

+--------+------------+-----------+-------------+

| 10 | vadgaon | Pune | Maharashtra |

| 11 | Link Road | Mumbai | Maharashtra |

| 12 | Park stree | Kolkata | West Bengal |

| 13 | Roha | Bangalore | Karnataka |

| 14 | Street roa | Cuttack | Orissa |

+--------+------------+-----------+-------------+

Now apply the all queries on above table

2. List the employee details along with branch name using the inner join and in the order of emp_no.

select emp_id,emp_name,branch_name from Empmaster e inner join Branchmaster b on

e.branch_id=b.branch_id order by emp_id;

select emp_id,emp_name,branch_name from Empmaster e full join Branchmaster b on

e.branch_id=b.branch_id order by emp_id;

3. List the details of employee who belong to admin department along with the branch

name to which they belong.

select emp_name,dept,branch_name from Branchmaster b,Empmaster e where

b.branch_id=e.branch_id and dept=’manager’;

4. List the employee name along with the phone no and city using inner join.

select emp_name,phone_no,city from Empmaster e inner join Empaddressdetails a on

e.emp_id=a.emp_id inner join contactdetails c on e.emp_id=c.emp_id;

5. List the employee name with the contact details (if any).

select emp_name,email_id,phone_no from Empmaster e left join contactdetails c on

e.emp_id=c.emp_id;

6. List the employee contact details irrespective of whether they are working or have left.

delete from Empmaster where emp_id=12;

select * from Empmaster;

select emp_name,email_id,phone_no from Empmaster e right join contactdetails c on

e.emp_id=c.emp_id;

7. Retrieve the employee name and their respective manager name.

select e1.emp_name,e2.emp_name as Manager from Empmaster e1,Empmaster e2 where

e1.manager_id=e2.emp_id;

8. List the employee details along with branch name using natural join.

select emp_name,dept,branch_name,salary from Branchmaster b natural join Empmaster e;

9. List the employee names who work at the vadgaon branch along with the city of that

employee.

select e.emp_id,emp_name,city from Empmaster e,Branchmaster b,Empaddressdetails a

where b.branch_name=’wagholi’ and b.branch_id=e.branch_id and e.emp_id=a.emp_id;

10. Find the employee who works at the vadgaon branch with salary>10000 and list the

employee names with streets and city they live in.

select emp_name,street,city,salary from Empmaster e,Empaddressdetails a where

e.emp_id=a.emp_id and e.emp_id in(select emp_id from Branchmaster b,Empmaster c where

branch_name=’Vadgaon’ and salary>10000 and b.branch_id=c.branch_id);

11. Find the employees who live and work in same city.

select emp_name from Empmaster e,Branchmaster b,Empaddressdetails

a,Branchaddress c where e.emp_id=a.emp_id and b.branch_id=e.branch_id and

c.branch_id=b.branch_id and c.city=a.city;

12. Find the employees whose salaries are more than everybody who works at branch

vadgaon.

select emp_name from Empmaster where salary>all(select salary from Empmaster

e,Branchmaster b where e.branch_id=b.branch_id and branch_name=’Vadgaon’);

13. Create a view which will contain total employees at each branch.

create view TotEmp as select branch_name,count(emp_id) as TotalEmployees from

Empmaster e,Branchmaster b where e.branch_id=b.branch_id group by e.branch_id;

select * from totemp;

14. List the branch names where employee have a salary>100000.

select branch_name from Empmaster e,Branchmaster b where e.branch_id=b.branch_id

and salary<100000;

15. Create a view which will show the avg salary and the total salary at each branch.

create view Emp as select branch_name,avg(salary),sum(salary) from Empmaster

e,Branchmaster b where e.branch_id=b.branch_id group by e.branch_id;

select * from emp;

16. Find the employee who do not have a job at vadgaon branch.

select emp_name from Empmaster e,Branchmaster b where e.branch_id=b.branch_id and

e.branch_id not in(select branch_id from Branchmaster where branch_name=’vadgaon’);